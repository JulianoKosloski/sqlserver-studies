USE AB_TREINAMENTO_JULIANOKOSLOSKI
GO

-- Lista 03
-- 1) Desenvolva duas triggers:

-- De inserção na tabela CONTAS, que deverá gravar o USUARIOINCLUSAO com o seu nome, e DATAINCLUSAO com a data corrente.

IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'TRG_CONTAS_INSERT')
BEGIN
	DROP TRIGGER TRG_CONTAS_INSERT
END;
GO

CREATE TRIGGER TRG_CONTAS_INSERT ON CONTAS
FOR INSERT AS 
BEGIN
	UPDATE CONTAS
	SET USUARIOINCLUSAO = 'Juliano Kosloski', DATAINCLUSAO = GETDATE()
	FROM CONTAS C 
	INNER JOIN INSERTED INS 
	ON (C.CODCOLIGADA = INS.CODCOLIGADA
		AND C.CODAGENCIA = INS.CODAGENCIA
		AND C.NROCONTA = INS.NROCONTA);
END;
GO 

-- Insira uma nova conta e realize a consulta da conta cadastrada. Verifique a gravação apenas dos campos USUARIOINCLUSAO e DATAINCLUSAO

INSERT INTO CONTAS (CODCOLIGADA,CODAGENCIA,NROCONTA,CODPESSOA,INDPOUPANCA) 
VALUES ('001', '002', '3215552', '002', 'S');

SELECT C.USUARIOINCLUSAO, C.DATAINCLUSAO FROM CONTAS C
WHERE C.NROCONTA = '3215552'

DROP TRIGGER TRG_CONTAS_INSERT;

-- De alteração na tabela CONTAS que deverá gravar o USUARIOALTERACAO com o seu nome, e DATAALTERACAO com a data corrente.

ALTER TABLE CONTAS ADD DATAALTERACAO DATETIME;
GO

IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'TRG_CONTAS_UPDATE')
BEGIN
	DROP TRIGGER TRG_CONTAS_UPDATE
END;
GO

CREATE TRIGGER TRG_CONTAS_UPDATE ON CONTAS
FOR UPDATE AS 
BEGIN

	UPDATE CONTAS
	SET USUARIOALTERACAO = 'Juliano Kosloski', DATAALTERACAO = GETDATE()
	FROM CONTAS C 
	INNER JOIN INSERTED INS 
	ON (C.CODCOLIGADA = INS.CODCOLIGADA
		AND C.CODAGENCIA = INS.CODAGENCIA
		AND C.NROCONTA = INS.NROCONTA);
END;
GO

-- Altere uma conta e realize a consulta da conta alterada. Verifique a gravação apenas dos campos USUARIOALTERACAO e DATAALTERACAO

UPDATE CONTAS  
SET NROCONTA = '3214442'
FROM CONTAS C
WHERE C.CODCOLIGADA = '001' AND C.CODAGENCIA = '002' AND NROCONTA = '3215552';

SELECT C.USUARIOALTERACAO, C.DATAALTERACAO FROM CONTAS C
WHERE C.NROCONTA = '3214442';

DROP TRIGGER TRG_CONTAS_UPDATE;

-- 2) Realize uma consulta que retorne a soma de todos os movimentos feitos a partir de um determinado período (01/01/2011 - 15/01/2011)

-- inserções adicionais para ter valores dentro do período
INSERT INTO MOVIMENTOS(CODCOLIGADA,CODAGENCIA,NROCONTA, DATAMOVIMENTO, VALOR, MORA, MULTA,DESCONTO, DESCRICAO) 
VALUES ('001', '002', '3214442', '20110110',2500.20,0.00,0.00,0.00,'aaa');

INSERT INTO MOVIMENTOS(CODCOLIGADA,CODAGENCIA,NROCONTA, DATAMOVIMENTO, VALOR, MORA, MULTA,DESCONTO, DESCRICAO) 
VALUES ('001', '002', '3214442', '20110108',46.00,17.57,3.50,0.00,'aaa');

INSERT INTO MOVIMENTOS(CODCOLIGADA,CODAGENCIA,NROCONTA, DATAMOVIMENTO, VALOR, MORA, MULTA,DESCONTO, DESCRICAO) 
VALUES ('001', '002', '3214442', '20110105',5142.40,7.10,0.00,1.88,'aaa');
--

SELECT SUM(M.VALOR) SOMA_MOVIMENTOS FROM MOVIMENTOS M
WHERE M.DATAMOVIMENTO BETWEEN '20110101' AND '20110115'

-- 3) Insira um novo cliente e não cadastre conta nem movimento para ele.

INSERT INTO PESSOAS(CODPESSOA, CPFCNPJ, NOME,DATANASCIMENTO, TIPOPESSOA, NUMEROFILHOS,INDCLIENTEBANCO, TIPOLOGRADOURO,LOGRADOURO,BAIRRO, CIDADE, UF, PAIS, CEP, OBSERVACAO) 
VALUES('007','54362862904','BEATRIZ MARIA PEREIRA', '20000628', 'F', DEFAULT, 'N', 'RUA', 'RUA NUMERO CINCO', 'SANTA MARIA', 'MARAPORA', 'RO', 'BRASIL', '80860901', 'bbb')

-- 4) Realize uma consulta que retorne os movimentos que foram realizados para o cliente com NOME iniciado por 'B'

SELECT P.NOME, C.NROCONTA, M.VALOR 
FROM PESSOAS P 
	INNER JOIN CONTAS C ON (P.CODPESSOA = C.CODPESSOA)
	INNER JOIN MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA AND
								C.CODAGENCIA = M.CODAGENCIA AND
								C.NROCONTA = M.NROCONTA)
WHERE P.NOME LIKE 'B%';

-- 5) Realize uma consulta que retorne apenas os clientes que não possuem movimentos
-- Talvez não seja o jeito mais eficiente
--nesse caso mostra apenas os clientes que não tem movimento em NENHUMA conta
SELECT P.NOME, C.NROCONTA 
FROM PESSOAS P 
INNER JOIN CONTAS C ON (P.CODPESSOA = C.CODPESSOA)
WHERE P.NOME NOT IN (SELECT P.NOME FROM PESSOAS P 
					INNER JOIN CONTAS C ON (P.CODPESSOA = C.CODPESSOA)
					INNER JOIN MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA AND
								C.CODAGENCIA = M.CODAGENCIA AND
								C.NROCONTA = M.NROCONTA))

--outro jeito (nesse caso mostra todos os pares CLIENTE, CONTA que não possuem movimento)
SELECT P.NOME, C.NROCONTA
FROM PESSOAS P
INNER JOIN CONTAS C ON (P.CODPESSOA = C.CODPESSOA)
LEFT JOIN MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA 
							AND C.CODAGENCIA = M.CODAGENCIA 
							AND C.NROCONTA = M.NROCONTA)
WHERE M.CODCOLIGADA IS NULL;

-- 6) Crie uma procedure utilizando os recursos de transação (begin, rollback e commit).

IF NOT EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'P_INSERE_CONTA')
BEGIN
	EXEC('CREATE PROCEDURE P_INSERE_CONTA AS BEGIN RETURN END');
END;
GO

ALTER PROC P_INSERE_CONTA (
	@P_CODCOLIGADA VARCHAR(3),
	@P_CODAGENCIA VARCHAR(5),
	@P_NROCONTA VARCHAR(7),
	@P_CODPESSOA VARCHAR(3),
	@P_INDPOUPANCA CHAR(1),
	@P_USUARIOINCLUSAO VARCHAR(100),
	@P_DATAINCLUSAO DATETIME)
AS 

DECLARE
@VALIDA VARCHAR(3), 
@DATA DATETIME = GETDATE();

BEGIN
	-- valida se o codpessoa passado como parametro existe na tabela pessoas
	BEGIN TRAN
	SELECT @VALIDA = P.CODPESSOA
		FROM PESSOAS P
		WHERE P.CODPESSOA = @P_CODPESSOA;

	IF @VALIDA IS NOT NULL
	BEGIN
		INSERT INTO CONTAS (CODCOLIGADA,CODAGENCIA,NROCONTA,CODPESSOA,INDPOUPANCA,USUARIOINCLUSAO, DATAINCLUSAO) 
		VALUES(@P_CODCOLIGADA, @P_CODAGENCIA, @P_NROCONTA,@P_CODPESSOA,@P_INDPOUPANCA, @P_USUARIOINCLUSAO, @DATA)
	END

	IF @@ERROR <> 0
	BEGIN
		ROLLBACK TRAN
	END
	ELSE
	BEGIN
		COMMIT TRAN
	END;
END;
GO

-----------

-- 7) Crie uma view que retorne apenas o número das contas que tem movimentos com valores acima de 1000,00. 
-- Realize uma consulta a partir desta view.

IF NOT EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'V_CONTAS_ACIMA_1000')
BEGIN
	EXEC('CREATE VIEW V_CONTAS_ACIMA_1000 AS SELECT * FROM CONTAS');
END;
GO

ALTER VIEW V_CONTAS_ACIMA_1000 AS
SELECT C.NROCONTA 
FROM CONTAS C
	INNER JOIN MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA 
								AND C.CODAGENCIA = M.CODAGENCIA
								AND C.NROCONTA = M.NROCONTA)
WHERE M.VALOR > 1000;
GO
SELECT * FROM V_CONTAS_ACIMA_1000;
GO
-- 8) Crie uma procedure com um cursor que leia a tabela MOVIMENTOS. Percorra o cursor e exiba ‘Movimento Alto’ para movimentos com VALOR acima de 1.000
-- e ‘Movimento Baixo’ para movimentos abaixo de 1.000.

IF NOT EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'P_CURSOR_MOVIMENTOS')
BEGIN
	EXEC('CREATE PROCEDURE P_CURSOR_MOVIMENTOS AS BEGIN RETURN END');
END;
GO

ALTER PROC P_CURSOR_MOVIMENTOS
AS

DECLARE @CODCOLIGADA VARCHAR(3),
		@CODAGENCIA VARCHAR(3),
		@NROCONTA VARCHAR(7),
		@NROMOVIMENTO INT,
		@VALOR NUMERIC(17,2);

BEGIN

	DECLARE PERCORRE_MOVIMENTOS CURSOR FOR
		SELECT M.CODCOLIGADA, M.CODAGENCIA, M.NROCONTA, M.NROMOVIMENTO, M.VALOR
		FROM MOVIMENTOS M

	OPEN PERCORRE_MOVIMENTOS

	FETCH NEXT FROM PERCORRE_MOVIMENTOS INTO @CODCOLIGADA, @CODAGENCIA, @NROCONTA, @NROMOVIMENTO, @VALOR
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @VALOR>1000
		BEGIN
			SELECT @CODCOLIGADA, @CODAGENCIA, @NROCONTA, @NROMOVIMENTO, CONVERT(VARCHAR(20), @VALOR) + ' - Movimento Alto'
		END
		ELSE
		BEGIN
			SELECT @CODCOLIGADA, @CODAGENCIA, @NROCONTA, @NROMOVIMENTO, CONVERT(VARCHAR(20), @VALOR) + ' - Movimento Baixo'
		END

		FETCH NEXT FROM PERCORRE_MOVIMENTOS INTO @CODCOLIGADA, @CODAGENCIA, @NROCONTA, @NROMOVIMENTO, @VALOR

	END
	CLOSE PERCORRE_MOVIMENTOS
	DEALLOCATE PERCORRE_MOVIMENTOS
END
GO

EXEC P_CURSOR_MOVIMENTOS


-- 9) Crie uma trigger de UPDATE para a tabela MOVIMENTOS. Verifique se o campo DATAMOVIMENTO foi
-- alterado, e caso ele tenha sido alterado, emita uma mensagem de erro se a data for menor que a data atual.

IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'TRG_MOVIMENTOS_UPDATE')
BEGIN
	DROP TRIGGER TRG_MOVIMENTOS_UPDATE
END;
GO

CREATE TRIGGER TRG_MOVIMENTOS_UPDATE ON MOVIMENTOS
FOR UPDATE AS 

DECLARE @ALTERADO INT = 0;
BEGIN

	SELECT @ALTERADO = 1 
	FROM INSERTED INS 
		INNER JOIN DELETED DEL ON(INS.CODCOLIGADA = DEL.CODCOLIGADA AND
									INS.CODAGENCIA = DEL.CODAGENCIA AND
									INS.NROCONTA = DEL.NROCONTA)
	WHERE INS.DATAMOVIMENTO <> DEL.DATAMOVIMENTO AND INS.DATAMOVIMENTO < GETDATE();

	IF @ALTERADO = 1
	BEGIN
		DECLARE @ERROR VARCHAR(255)
		SET @ERROR = 'A DATAMOVIMENTO que foi atualizada é anterior à data atual.'
		RAISERROR (@ERROR, 16, 1)
	END
END;
GO

UPDATE MOVIMENTOS
SET DATAMOVIMENTO = '20210323'
WHERE CODCOLIGADA = '001'

SELECT * FROM MOVIMENTOS

-- 10) Crie uma função que calcule o saldo anterior do movimento, que é a soma de todos os movimentos da
-- conta cuja data é menor que a data atual. Apresente os movimentos das contas com a data do
-- movimento, valor do movimento, saldo anterior e calcule o saldo atual que é o valor do movimento
-- mais o saldo anterior.

IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'F_MOV_SALDO_ANTERIOR')
BEGIN
	DROP FUNCTION F_MOV_SALDO_ANTERIOR
END;
GO

CREATE FUNCTION F_MOV_SALDO_ANTERIOR (
				@CODCOLIGADA VARCHAR(3),
				@CODAGENCIA VARCHAR(3),
				@NROCONTA VARCHAR(7),
				@DATA_ATUAL DATETIME)
RETURNS NUMERIC(17,2)
WITH EXECUTE AS CALLER
AS BEGIN

	DECLARE @SALDO_ANTERIOR NUMERIC(17,2) = (SELECT SUM(M.VALOR) 
												FROM MOVIMENTOS M 
												WHERE M.CODCOLIGADA = @CODCOLIGADA AND
												M.CODAGENCIA = @CODAGENCIA AND
												M.NROCONTA = @NROCONTA AND
												M.DATAMOVIMENTO < @DATA_ATUAL)

	IF @SALDO_ANTERIOR IS NULL 
	BEGIN
		SET @SALDO_ANTERIOR = 0.00
	END

	RETURN @SALDO_ANTERIOR

END
GO

-- atualizando algumas entradas de DATAMOVIMENTO para não zerar a função em todas as linhas

SELECT * FROM MOVIMENTOS

UPDATE MOVIMENTOS 
SET DATAMOVIMENTO = '20190405'
WHERE NROMOVIMENTO = 8

UPDATE MOVIMENTOS 
SET DATAMOVIMENTO = '20090415'
WHERE NROMOVIMENTO = 10

UPDATE MOVIMENTOS 
SET DATAMOVIMENTO = '20080415'
WHERE NROMOVIMENTO = 7

UPDATE MOVIMENTOS 
SET DATAMOVIMENTO = '19970625'
WHERE NROMOVIMENTO = 4

UPDATE MOVIMENTOS 
SET DATAMOVIMENTO = '20110215'
WHERE NROMOVIMENTO = 2

SELECT M.CODCOLIGADA,
	M.CODAGENCIA, 
	M.NROCONTA, 
	M.DATAMOVIMENTO, 
	M.VALOR, 
	DBO.F_MOV_SALDO_ANTERIOR (M.CODCOLIGADA, M.CODAGENCIA, M.NROCONTA, M.DATAMOVIMENTO) AS SALDO_ANTERIOR,
	M.VALOR + (DBO.F_MOV_SALDO_ANTERIOR (M.CODCOLIGADA, M.CODAGENCIA, M.NROCONTA, M.DATAMOVIMENTO)) AS SALDO_ATUAL 
	FROM MOVIMENTOS M
	ORDER BY M.CODCOLIGADA, M.CODAGENCIA, M.NROCONTA, M.DATAMOVIMENTO 

---- OPCIONAIS

-- 1) Crie uma procedure que some 10,00 no campo DESCONTO e subtraia 10,00 do campo VALOR da tabela
-- MOVIMENTOS para todos os clientes que:

-- Tem conta poupança (INDPOUPANCA = S) e o dia e o mês do campo DATANASCIMENTO da tabela PESSOA seja igual ao dia e o mês do campo DATAMOVIMENTO da tabela MOVIMENTO (daquela pessoa)

IF NOT EXISTS (SELECT NAME FROM SYSOBJECTS WHERE NAME = 'P_DESCONTO_10_ANIVERSARIO')
BEGIN
	EXEC('CREATE PROCEDURE P_DESCONTO_10 AS BEGIN RETURN END');
END;
GO

ALTER PROC P_DESCONTO_10_ANIVERSARIO
AS BEGIN

	UPDATE MOVIMENTOS
	SET VALOR = (VALOR - 10.00), DESCONTO = (DESCONTO + 10.00)
	FROM PESSOAS P INNER JOIN CONTAS C ON (P.CODPESSOA=C.CODPESSOA)
					INNER JOIN MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA AND
												C.CODAGENCIA = M.CODAGENCIA AND
												C.NROCONTA = M.NROCONTA)
	WHERE DATEPART(DD, M.DATAMOVIMENTO) = DATEPART(DD, P.DATANASCIMENTO) 
		AND DATEPART(MM, DATAMOVIMENTO) = DATEPART(MM, P.DATANASCIMENTO) 

END

-- Antes de executar a procedure:
-- Insira uma nova pessoa com data de nascimento 05/01/1990 e insira um movimento para esta pessoa no dia 05/01/2010 com VALOR = 100,00

INSERT INTO PESSOAS(CODPESSOA,CPFCNPJ,NOME,DATANASCIMENTO,TIPOPESSOA,NUMEROFILHOS,INDCLIENTEBANCO, TIPOLOGRADOURO,LOGRADOURO,BAIRRO,CIDADE,UF,PAIS,CEP, OBSERVACAO)
VALUES ('025', '10328363305', 'ANITA GARIBALDI','19900105', 'F', DEFAULT, 'S', 'RUA', 'RUA DAS AMELIAS', 'SANTA CRUZ', 'SANTA CRUZ DO NORTE', 'GO', 'BRASIL', '80510344', 'bbb');

INSERT INTO CONTAS(CODCOLIGADA,CODAGENCIA,NROCONTA,CODPESSOA,INDPOUPANCA,USUARIOINCLUSAO,DATAINCLUSAO)
VALUES ('025', '025', '2500027','025', 'S','Robertinho', '20220527');

INSERT INTO MOVIMENTOS(CODCOLIGADA,CODAGENCIA,NROCONTA,DATAMOVIMENTO,VALOR,MORA,MULTA,DESCONTO,DESCRICAO) 
VALUES('025', '025', '2500027','20100105',100.00, 0.00, 0.00, 0.00, 'cccccsda');

-- Insira um movimento para a mesma pessoa no dia 07/01/2010 com VALOR = 100,00

INSERT INTO MOVIMENTOS(CODCOLIGADA,CODAGENCIA,NROCONTA,DATAMOVIMENTO,VALOR,MORA,MULTA,DESCONTO,DESCRICAO) 
VALUES('025', '025', '2500027','20100107',100.00, 0.00, 0.00, 0.00, 'cccccsda');

-- EXECUTE a procedure e realize uma consulta na tabela MOVIMENTO para verificar se o DESCONTO de 10,00
-- foi dado para a pessoa e se foi abatido o valor de 10 reais do campo VALOR, na tabela MOVIMENTOS, de
-- acordo com as condições impostas pelo exercício. Apenas para um dos movimentos o desconto deve ter
-- sido concedido e o valor abatido.

EXEC P_DESCONTO_10_ANIVERSARIO;

SELECT M.CODCOLIGADA, M.CODAGENCIA, M.NROCONTA, M.DATAMOVIMENTO, M.VALOR, M.DESCONTO 
FROM MOVIMENTOS M
WHERE M.CODCOLIGADA = '025' AND
	M.CODAGENCIA = '025' AND
	M.NROCONTA = '2500027'

-- 2) Realize uma consulta que busque todas as contas (não repetir a conta) que possuem movimentos com desconto.

SELECT DISTINCT C.NROCONTA AS CONTAS_MOV_DESCONTO 
FROM CONTAS C INNER JOIN
	MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA AND
					C.CODAGENCIA = M.CODAGENCIA AND
					C.NROCONTA = M.NROCONTA)
WHERE M.DESCONTO > 0.00

-- 3) Realize uma consulta que retorne apenas o ano de cada registro da tabela movimentos.

SELECT M.NROMOVIMENTO, DATEPART(YYYY, M.DATAMOVIMENTO) AS ANO 
FROM MOVIMENTOS M

-- 4) Realize uma consulta na tabela Contas que retorne Sim caso o valor do campo INDPOUPANCA seja igual a
-- 'S', ou Não caso o valor do campo INDPOUPANCA seja igual a 'N', desde que o cliente que possua esta conta
-- seja cliente do banco (INDCLIENTEBANCO = S).

SELECT P.CODPESSOA, 
		P.NOME, 
		C.NROCONTA, 
		CASE C.INDPOUPANCA 
			WHEN 'S' THEN 'Sim'
			WHEN 'N' THEN 'Não'
		END
		AS POUPANCA
FROM PESSOAS P INNER JOIN CONTAS C ON (P.CODPESSOA = C.CODPESSOA)
WHERE P.INDCLIENTEBANCO = 'S'

-- 5) Elabore um consulta qualquer utilizando LEFT JOIN, RIGHT JOIN e JOIN e descreva o propósito dessa consulta.

--mostra todos os dados das pessoas cadastradas e suas respectivas contas, permitindo verificar quais clientes não possuem conta (campos nulos)
SELECT * FROM PESSOAS P LEFT JOIN
				CONTAS C ON (P.CODPESSOA = C.CODPESSOA)

-- permite verificar todos os dados relacionados à movimento e se algum deles não está associado com uma conta na tabela CONTAS
SELECT * FROM CONTAS C RIGHT JOIN
				MOVIMENTOS M ON (C.CODCOLIGADA = M.CODCOLIGADA AND
									C.CODAGENCIA = M.CODAGENCIA AND
									C.NROCONTA = M.NROCONTA)

-- mostra todos os valores das duas tabelas independente da relação entre elas
SELECT * FROM PESSOAS P JOIN
				CONTAS C ON (P.CODPESSOA = C.CODPESSOA)


-- 6) Elabore uma consulta que retorne os campos valor, mora e multa da tabela movimentos, garantindo que, se
-- o valor a ser exibido for null, retorne zero.

SELECT M.NROMOVIMENTO, ISNULL(M.VALOR, 0.00) AS VALOR, ISNULL(M.MORA, 0.00) AS MORA, ISNULL(M.MULTA, 0.00) AS MULTA
FROM MOVIMENTOS M

